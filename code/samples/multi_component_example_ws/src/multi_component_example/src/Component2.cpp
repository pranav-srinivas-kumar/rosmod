#include "Component2.hpp"

using namespace Node1;

// -------------------------------------------------------
// BUSINESS LOGIC OF THESE FUNCTIONS SUPPLIED BY DEVELOPER
// -------------------------------------------------------

void Component2::Timer0Callback(const ros::TimerEvent& event)
{ 
  multi_component_example::ComponentService srv;
  srv.request.operation = "GetComponentName";
  LOGGER.DEBUG("COMPONENT 2 : Invoking ComponentService from Timer0 callback");
  if (compServClient.call(srv))
    {
      LOGGER.DEBUG("COMPONENT 2 : Got name of other component: " + srv.response.name);
    }
  else
    {
      LOGGER.ERROR("COMPONENT 2 : Failed to invoke operation");
      compServClient.waitForExistence(ros::Duration(-1));
    }
}

// ---------------------------------------------
// EVERYTHING BELOW HERE IS COMPLETELY GENERATED
// ---------------------------------------------

// required for clean shutdown when process is killed
Component2::~Component2()
{
  // These will be autogenerated based on the model
  Timer0.stop();
  compServClient.shutdown();
}

void Component2::startUp()
{
  ros::NodeHandle nh;

  // configure all subscribers associated with this component

  // configure all publishers associated with this component

  // configure all advertised services associated with this component

  // configure all required services associated with this component
  this->compServClient = nh.serviceClient<multi_component_example::ComponentService>("ComponentService");

  // create the timers last to ensure we don't start off with too many callbacks in the queue
  ros::TimerOptions queueTimerOpts;

  // need to start any timers this component contains
  queueTimerOpts = ros::TimerOptions(
				     ros::Duration(2.0),  // this value would be filled out by model
				     boost::bind(&Component2::Timer0Callback, this, _1),
				     &this->compQueue
				     );
  this->Timer0 = nh.createTimer(queueTimerOpts);

  LOGGER.CREATE_FILE("/home/kelsier/Documents/Component2_log.txt");
}
