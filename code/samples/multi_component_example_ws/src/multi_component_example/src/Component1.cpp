#include "Component1.hpp"

using namespace Node1;

// -------------------------------------------------------
// BUSINESS LOGIC OF THESE FUNCTIONS SUPPLIED BY DEVELOPER
// -------------------------------------------------------

void Component1::Timer0Callback(const ros::TimerEvent& event)
{ 
  multi_component_example::ComponentName compName;
  compName.name = "Component1";

  LOGGER.DEBUG("COMPONENT 1 : Publishing component name " + 
	       compName.name + " from Timer0 callback");

  compNamePub.publish(compName); 
}

bool Component1::ComponentServiceCallback(multi_component_example::ComponentService::Request  &req,
					  multi_component_example::ComponentService::Response &res)
{
  multi_component_example::ComponentName compName;
  compName.name = "Component1";

  LOGGER.DEBUG("COMPONENT 1 : Publishing component name " 
	       + compName.name + " from compServ callback");

  compNamePub.publish(compName); 
  res.name = "Component1";
  return true;
}

// ---------------------------------------------
// EVERYTHING BELOW HERE IS COMPLETELY GENERATED
// ---------------------------------------------

// required for clean shutdown when process is killed
Component1::~Component1()
{
  // These will be autogenerated based on the model
  Timer0.stop();
  compNamePub.shutdown();
  compServ.shutdown();
}

void Component1::startUp()
{
  ros::NodeHandle nh;

  // configure all subscribers associated with this component

  // configure all publishers associated with this component
  this->compNamePub = nh.advertise<multi_component_example::ComponentName>
    ("ComponentName", 1000);

  // configure all advertised services associated with this component
  ros::AdvertiseServiceOptions queueServOpts;

  queueServOpts = ros::AdvertiseServiceOptions::create<multi_component_example::ComponentService>
    (
     "ComponentService", 
     boost::bind(&Component1::ComponentServiceCallback, this, _1, _2),
     ros::VoidPtr(),//(ros::VoidConstPtr)this,
     &this->compQueue
     );
  this->compServ = nh.advertiseService(queueServOpts);

  // create the timers last to ensure we don't start off with too many callbacks in the queue
  ros::TimerOptions queueTimerOpts;

  // need to start any timers this component contains
  queueTimerOpts = ros::TimerOptions(
				     ros::Duration(1.0),  // this value would be filled out by model
				     boost::bind(&Component1::Timer0Callback, this, _1),
				     &this->compQueue
				     );
  this->Timer0 = nh.createTimer(queueTimerOpts);

  LOGGER.CREATE_FILE("/home/kelsier/Documents/Component1_log.txt");
}
