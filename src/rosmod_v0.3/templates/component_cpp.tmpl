#unicode utf8
$hash_include "$package_name/${component_name}.hpp"

#if $component_type == "KSP"
KRPCI krpci_client;
#end if
#if $component_type == "SUMO"
SUMO_CLIENT sumo_client;
#end if

#if $user_globals == ""
//# Start User Globals Marker
//# End User Globals Marker
#else
//# Start User Globals Marker
$user_globals//# End User Globals Marker
#end if

// Initialization Function
#if $init_business_logic == ""
//# Start Init Marker
void $component_name::Init(const ros${mod}::TimerEvent& event)
{
#if $mod != ""
  compQueue.ROSMOD_LOGGER.DEBUG("Entering $component_name::Init");
#end if
  // Initialize Here
#if $component_type == "SUMO"
  std::string sumo_host;
  int sumo_port;
  for (int i=0; i<node_argc; i++)
    {
      if (!strcmp(node_argv[i], "--sumo_host"))
	{
	  sumo_host = node_argv[i+1];
	}
      if (!strcmp(node_argv[i], "--sumo_port"))
	{
	  sumo_port = atoi(node_argv[i+1]);
	}
    }
  sumo_client.create_connection(sumo_port, sumo_hostname);
#end if
#if $component_type == "KSP"
  std::string ksp_host;
  int ksp_port;
  for (int i=0; i<node_argc; i++)
    {
      if (!strcmp(node_argv[i], "--ksp_host"))
	{
	  ksp_host = node_argv[i+1];
	}
      if (!strcmp(node_argv[i], "--ksp_port"))
	{
	  ksp_port = atoi(node_argv[i+1]);
	}
    }
  krpci_client.SetPort(ksp_port);
  krpci_client.SetIP(ksp_host);
#end if
#if $trafficGen
  srand (time(NULL));
  double tg_duration = -1;
  std::string fName;
  for (int i=0; i<node_argc; i++)
    {
      if (!strcmp(node_argv[i], "--tg_time"))
	{
	  tg_duration = atof(node_argv[i+1]);
	}
    }
#if $len($subscribers) > 0
  uint64_t capacityBits = 400000;
  bool enable_sendback = true;
  for (int i=0; i<node_argc; i++)
    {
      if (!strcmp(node_argv[i], "--buffer_capacity_bits"))
	{
	  capacityBits = atoi(node_argv[i+1]);
	}
      if (!strcmp(node_argv[i], "--buffer_capacity_bytes"))
	{
	  capacityBits = atoi(node_argv[i+1]) * 8;
	}
      if (!strcmp(node_argv[i], "--disable_sendback"))
	{
	  enable_sendback = false;
	}
    }
#for $sub in $subscribers
  if (config.profileMap.find("$sub.properties['name']") != config.profileMap.end())
    {
      ${sub.properties['name']}_recv_mw.init(node_argc,
					     node_argv,
					     config.profileMap["$sub.properties['name']"],
					     capacityBits);
      if ( tg_duration < 0 )
	${sub.properties['name']}_recv_mw.set_duration(${sub.properties['name']}_recv_mw.profile.period);
      else
	${sub.properties['name']}_recv_mw.set_duration(tg_duration);
      fName = nodeName + "." + compName + ".${sub.properties['name']}.network.csv";
      ${sub.properties['name']}_recv_mw.set_enable_sendback(enable_sendback);
      ${sub.properties['name']}_recv_mw.set_output_filename(fName);
      ${sub.properties['name']}_recv_mw.set_recv_done_callback(boost::bind(&$component_name::mw_recv_done_callback, this, &${sub.properties['name']}_recv_mw));
      ${sub.properties['name']}_id = 0;
    }
  if (config.portSenderMap.find("$sub.properties['name']") != config.portSenderMap.end())
    {
      for (auto it=config.portSenderMap["$sub.properties['name']"].begin();
	   it != config.portSenderMap["$sub.properties['name']"].end(); ++it)
	{
	  ${sub.properties['name']}_recv_mw.add_sender( it->first, it->second );
	}
    }
  
#end for
#end if
#if $len($publishers) > 0
  max_data_length = 8192;
  tg_misbehave = false;
  for (int i=0; i<node_argc; i++)
    {
      if (!strcmp(node_argv[i], "--max_data_length_bytes"))
	{
	  max_data_length = atoi(node_argv[i+1]);
	}
      if (!strcmp(node_argv[i], "--max_data_length_bits"))
	{
	  max_data_length = atoi(node_argv[i+1]) / 8;
	}
      if (!strcmp(node_argv[i], "--tg_misbehave"))
	{
	  tg_misbehave = true;
	}
    }
  ros::NodeHandle nh;
  ros::TimerOptions timer_options;
#for $pub in $publishers
  if (config.profileMap.find("$pub.properties['name']") != config.profileMap.end())
    {
      ${pub.properties['name']}_send_mw.init(node_argc,
					     node_argv,
					     config.uuidMap["$pub.properties['name']"],
					     config.profileMap["$pub.properties['name']"]);
      if ( tg_duration < 0 )
	${pub.properties['name']}_send_mw.set_duration(${pub.properties['name']}_send_mw.profile.period);
      else
	${pub.properties['name']}_send_mw.set_duration(tg_duration);
      fName = nodeName + "." + compName + ".${pub.properties['name']}.network.csv";
      ${pub.properties['name']}_send_mw.set_output_filename(fName);

      timer_options = 
	ros::TimerOptions
	(ros::Duration(-1),
	 boost::bind(&$component_name::${pub.properties['name']}_timerCallback, this, _1),
	 &this->compQueue,
	 true);
      ${pub.properties['name']}_timer = nh.createTimer(timer_options);
    }
#end for
#end if
#end if
  // Stop Init Timer
  initOneShotTimer.stop();
#if $mod != ""
  compQueue.ROSMOD_LOGGER.DEBUG("Exiting $component_name::Init");
#end if  
}
//# End Init Marker
#else
//# Start Init Marker
$init_business_logic//# End Init Marker
#end if


#if $len($publishers) > 0
#for $pub in $publishers
void $component_name::${pub.properties['name']}_timerCallback(const ros::TimerEvent& event)
{
  $pub.properties["message_reference"].parent.properties["name"]::${pub.properties["message_reference"].properties["name"]} msg;
  msg.uuid = ${pub.properties['name']}_send_mw.get_uuid();
  msg.bytes.resize(max_data_length,0);
  double timerDelay = 0;
  try
    {
      timerDelay =
	${pub.properties['name']}_send_mw.send<$pub.properties["message_reference"].parent.properties["name"]::${pub.properties["message_reference"].properties["name"]}>($pub.properties['name'], msg);
    }
  catch ( Network::Exceeded_Production_Profile& ex )
    {
      LOGGER.DEBUG("Prevented from sending on the network!");
    }

  if ( ros::Time::now() >= ${pub.properties['name']}_send_mw.get_end_time() )
    {
      LOGGER.DEBUG("writing output\n");
      ${pub.properties['name']}_send_mw.record();
    }
  else
    {
      if (tg_misbehave)
	timerDelay -= 0.1;
      ros::TimerOptions timer_options;
      timer_options = 
	ros::TimerOptions
	(ros::Duration(timerDelay),
	 boost::bind(&$component_name::${pub.properties['name']}_timerCallback, this, _1),
	 &this->compQueue,
	 true);
      ros::NodeHandle nh;
      ${pub.properties['name']}_timer = nh.createTimer(timer_options);
    }
}
#end for
#end if

#if $len($subscribers) > 0
#if $trafficGen
void $component_name::mw_recv_done_callback(Network::receiver* receiver_mw)
{
  LOGGER.DEBUG("Writing middleware log.");
  LOGGER.DEBUG("Max middleware buffer: %lu bits", receiver_mw->buffer.maxBits());
  receiver_mw->record();
}
#end if

#for $sub in $subscribers
// Subscriber Callback - ${sub.properties["name"]}
#if $sub.properties["business_logic"] == ""
//# Start ${sub.properties["name"]}_OnOneData Marker
void $component_name::${sub.properties["name"]}_OnOneData(const $sub.properties["message_reference"].parent.properties["name"]::${sub.properties["message_reference"].properties["name"]}::ConstPtr& received_data)
{
#if $mod != ""
  compQueue.ROSMOD_LOGGER.DEBUG("Entering $component_name::${sub.properties["name"]}_OnOneData");
#end if
  // Business Logic for $sub.properties["name"] Subscriber

#if $trafficGen
  uint64_t uuid = received_data->uuid;
  uint64_t msgBytes = ros::serialization::Serializer<$sub.properties["message_reference"].parent.properties["name"]::${sub.properties["message_reference"].properties["name"]}>::serializedLength(*received_data);
  ros::Time now = ros::Time::now();
  ${sub.properties['name']}_recv_mw.update_sender_stream(uuid, now, msgBytes * 8);
  Network::Message new_msg;
  new_msg.Bytes(msgBytes);
  new_msg.Id(${sub.properties['name']}_id++);
  new_msg.TimeStamp();
  ${sub.properties['name']}_recv_mw.buffer.send(new_msg, msgBytes * 8);
#end if
  
#if $mod != ""
  compQueue.ROSMOD_LOGGER.DEBUG("Exiting $component_name::${sub.properties["name"]}_OnOneData");
#end if
}
//# End ${sub.properties["name"]}_OnOneData Marker
#else
//# Start ${sub.properties["name"]}_OnOneData Marker
$sub.properties["business_logic"]//# End ${sub.properties["name"]}_OnOneData Marker
#end if
#end for

#end if
#if $len($provided_services) > 0
#for $server in $servers
// Server Callback - $server.properties["name"]
#if $server.properties["business_logic"] == ""
//# Start ${server.properties["service_reference"].properties["name"]}Callback Marker
bool $component_name::${server.properties["service_reference"].properties["name"]}Callback($server.properties["service_reference"].parent.properties["name"]::$server.properties["service_reference"].properties["name"]::Request  &req,
  $server.properties["service_reference"].parent.properties["name"]::$server.properties["service_reference"].properties["name"]::Response &res)
{
#if $mod != ""
  compQueue.ROSMOD_LOGGER.DEBUG("Entering $component_name::${server.properties["service_reference"].properties["name"]}Callback");
#end if
  // Business Logic for $server.properties["name"] Server

#if $mod != ""
  compQueue.ROSMOD_LOGGER.DEBUG("Exiting $component_name::${server.properties["service_reference"].properties["name"]}Callback");
#end if
  return true;
}
//# End ${server.properties["service_reference"].properties["name"]}Callback Marker
#else
//# Start ${server.properties["service_reference"].properties["name"]}Callback Marker
$server.properties["business_logic"]//# End ${server.properties["service_reference"].properties["name"]}Callback Marker
#end if
#end for

#end if
#if $len($timers) > 0
#for $timer in $timers
// Timer Callback - $timer.properties["name"]
#if $timer.properties["business_logic"] == ""
//# Start ${timer.properties["name"]}Callback Marker
void $component_name::${timer.properties["name"]}Callback(const ros${mod}::TimerEvent& event)
{
#if $mod != ""
  compQueue.ROSMOD_LOGGER.DEBUG("Entering $component_name::${timer.properties["name"]}Callback");
#end if
  // Business Logic for $timer.properties["name"] Timer

#if $mod != ""
  compQueue.ROSMOD_LOGGER.DEBUG("Exiting $component_name::${timer.properties["name"]}Callback");
#end if
}
//# End ${timer.properties["name"]}Callback Marker
#else
//# Start ${timer.properties["name"]}Callback Marker
$timer.properties["business_logic"]//# End ${timer.properties["name"]}Callback Marker
#end if
#end for

#end if

// Destructor - Cleanup Ports & Timers
$component_name::~${component_name}()
{
#if $len($timers) > 0
#for $timer in $timers
  ${timer.properties["name"]}.stop();
#end for
#end if
#if $len($publishers) > 0
#for $pub in $publishers
  ${pub.properties["name"]}.shutdown();
#end for
#end if
#if $len($subscribers) > 0
#for $sub in $subscribers
  ${sub.properties["name"]}.shutdown();
#end for
#end if
#if $len($provided_services) > 0
#for $server in $servers
  ${server.properties["name"]}.shutdown();
#end for
#end if
#if $len($required_services) > 0
#for $client in $clients
  ${client.properties["name"]}.shutdown();
#end for
#end if
#if $destructor == ""
  //# Start Destructor Marker
  //# End Destructor Marker
#else
  //# Start Destructor Marker
$destructor  //# End Destructor Marker
#end if
}

// Startup - Setup Component Ports & Timers
void $component_name::startUp()
{
  ros${mod}::NodeHandle nh;
  std::string advertiseName;

  // Scheduling Scheme is FIFO
#if $mod != ""  
  this->compQueue.scheduling_scheme = scheduling_scheme;
  rosmod::ROSMOD_Callback_Options callback_options;
#end if  

#if $len($subscribers) > 0 
#for $sub in $subscribers
#if $mod != ""  
  callback_options.alias = "${sub.properties["name"]}_OnOneData";
  callback_options.priority = $sub.properties["priority"];
  callback_options.deadline.sec = ${int(sub.properties["deadline"].split('.')[0])};
  callback_options.deadline.nsec = ${int(float('0.' + (sub.properties["deadline"].split('.')[1]))*1000000000)};
#end if  
  // Component Subscriber - $sub.properties["name"]
  advertiseName = "${sub.properties["message_reference"].properties["name"]}";
  if (portGroupMap.find("$sub.properties["name"]") != portGroupMap.end())
    advertiseName += "_" + portGroupMap["${sub.properties['name']}"];
  ros${mod}::SubscribeOptions ${sub.properties["name"]}_options;
#if $mod != ""  
  ${sub.properties["name"]}_options = ros${mod}::SubscribeOptions::create<$sub.properties["message_reference"].parent.properties["name"]::${sub.properties["message_reference"].properties["name"]}>
      (advertiseName.c_str(),
       1000,
       boost::bind(&$component_name::${sub.properties["name"]}_OnOneData, this, _1),
       ros${mod}::VoidPtr(),
       &this->compQueue,
       callback_options);
  this->${sub.properties["name"]} = nh.subscribe(${sub.properties["name"]}_options);
#else
  ${sub.properties["name"]}_options = ros::SubscribeOptions::create<$sub.properties["message_reference"].parent.properties["name"]::${sub.properties["message_reference"].properties["name"]}>
      (advertiseName.c_str(),
       1000,
       boost::bind(&$component_name::${sub.properties["name"]}_OnOneData, this, _1),
       ros::VoidPtr(),
       &this->compQueue);
  this->${sub.properties["name"]} = nh.subscribe(${sub.properties["name"]}_options);  
#end if
#end for

#end if		
#if $len($publishers) > 0
#for $pub in $publishers
  // Component Publisher - $pub.properties["name"]
  advertiseName = "${pub.properties["message_reference"].properties["name"]}";
  if (portGroupMap.find("$pub.properties["name"]") != portGroupMap.end())
    advertiseName += "_" + portGroupMap["$pub.properties["name"]"];
  this->${pub.properties["name"]} = nh.advertise<$pub.properties["message_reference"].parent.properties["name"]::${pub.properties["message_reference"].properties["name"]}>(advertiseName.c_str(), 1000);
#end for

#end if
#if $len($provided_services)
#for $server in $servers
#if $mod != ""  
  callback_options.alias = "${server.properties["service_reference"].properties["name"]}Callback";
  callback_options.priority = $server.properties["priority"];
  callback_options.deadline.sec =${int(server.properties["deadline"].split('.')[0])};
  callback_options.deadline.nsec = ${int(float('0.' + (server.properties["deadline"].split('.')[1]))*1000000000)};
#end if    
  // Component Server - $server.properties["name"]
  advertiseName = "$server.properties["service_reference"].properties["name"]";
  if (portGroupMap.find("$server.properties["name"]") != portGroupMap.end())
    advertiseName += "_" + portGroupMap["$server.properties["name"]"];
  ros${mod}::AdvertiseServiceOptions ${server.properties["name"]}_server_options;
#if $mod != ""  
  ${server.properties["name"]}_server_options = ros${mod}::AdvertiseServiceOptions::create<$server.properties["service_reference"].parent.properties["name"]::$server.properties["service_reference"].properties["name"]>
      (advertiseName.c_str(),
       boost::bind(&$component_name::${server.properties["service_reference"].properties["name"]}Callback, this, _1, _2),
       ros${mod}::VoidPtr(),
       &this->compQueue,
       callback_options);
  this->${server.properties["name"]} = nh.advertiseService(${server.properties["name"]}_server_options);
#else
  ${server.properties["name"]}_server_options = ros::AdvertiseServiceOptions::create<$server.properties["service_reference"].parent.properties["name"]::$server.properties["service_reference"].properties["name"]>
      (advertiseName.c_str(),
       boost::bind(&$component_name::${server.properties["service_reference"].properties["name"]}Callback, this, _1, _2),
       ros::VoidPtr(),
       &this->compQueue);
  this->${server.properties["name"]} = nh.advertiseService(${server.properties["name"]}_server_options);  
#end if  
#end for
 
#end if
#if $len($required_services) > 0
  // Configure all required services associated with this component
#for $client in $clients
  // Component Client - $client.properties["name"]
  advertiseName = "$client.properties["service_reference"].properties["name"]";
  if (portGroupMap.find("$client.properties["name"]") != portGroupMap.end())
    advertiseName += "_" + portGroupMap["$client.properties["name"]"];
  this->${client.properties["name"]} = nh.serviceClient<$client.properties["service_reference"].parent.properties["name"]::$client.properties["service_reference"].properties["name"]>(advertiseName.c_str(), true); 
#end for

#end if
  // Init Timer
#if $mod != ""      
  callback_options.alias = "Init_Timer";
  callback_options.priority = 99;
  callback_options.deadline.sec = 1;
  callback_options.deadline.nsec = 0;
  ros${mod}::TimerOptions timer_options;
  timer_options = 
    ros${mod}::TimerOptions
    (ros::Duration(-1),
     boost::bind(&$component_name::Init, this, _1),
     &this->compQueue,
     callback_options,
     true,
     false);
#else  
  ros${mod}::TimerOptions timer_options;
  timer_options = 
    ros${mod}::TimerOptions
    (ros::Duration(-1),
     boost::bind(&$component_name::Init, this, _1),
     &this->compQueue,
     true,
     false);
#end if  
  this->initOneShotTimer = nh.createTimer(timer_options);
  this->initOneShotTimer.stop();
#if $len($timers)
#for $timer in $timers
#if $mod != ""      
  callback_options.alias = "${timer.properties["name"]}Callback";
  callback_options.priority = $timer.properties["priority"];
  callback_options.deadline.sec = ${int(timer.properties["deadline"].split('.')[0])};
  callback_options.deadline.nsec = ${int(float('0.' + (timer.properties["deadline"].split('.')[1]))*1000000000)};
  // Component Timer - $timer.properties["name"]
  timer_options = 
    ros${mod}::TimerOptions
#if $timer.properties["period"] == "0.0"
    (ros::Duration(-1),
#else
    (ros::Duration($timer.properties["period"]),
#end if
     boost::bind(&$component_name::${timer.properties["name"]}Callback, this, _1),
#if $timer.properties["period"] == "0.0"
     &this->compQueue,
     callback_options,
     true,
     false);
#else
     &this->compQueue,
     callback_options,
     false,
     false);
#end if 
#else 
  // Component Timer - $timer.properties["name"]
  timer_options = 
    ros${mod}::TimerOptions
#if $timer.properties["period"] == "0.0"
    (ros::Duration(-1),
#else
    (ros::Duration($timer.properties["period"]),
#end if
     boost::bind(&$component_name::${timer.properties["name"]}Callback, this, _1),
#if $timer.properties["period"] == "0.0"
     &this->compQueue, true, false);
#else
     &this->compQueue, false, false);
#end if 
#end if
  this->$(timer.properties["name"]) = nh.createTimer(timer_options);
#end for

#end if
  // Identify the pwd of Node Executable
  std::string s = node_argv[0];
  std::string exec_path = s;
  std::string delimiter = "/";
  std::string exec, pwd;
  size_t pos = 0;
  while ((pos = s.find(delimiter)) != std::string::npos) {
    exec = s.substr(0, pos);
    s.erase(0, pos + delimiter.length());
  }
  exec = s.substr(0, pos);
  pwd = exec_path.erase(exec_path.find(exec), exec.length());
  std::string log_file_path = pwd + nodeName + "." + compName + ".log"; 
  
  // Create the log file & open file stream
  LOGGER.CREATE_FILE(log_file_path);
  
  // Establish log levels of LOGGER
  LOGGER.SET_LOG_LEVELS(logLevels);

#if $component_type == "KSP"
  krpci_client.SetName(nodeName + "_" + compName);
#end if

  this->Comp_Sync_Pub = Nh.Advertise<Std_Msgs::Bool>("Component_Synchronization", 1000);
  
  ros${mod}::Subscribeoptions Comp_Sync_Sub_Options;
#if $mod != ""
  rosmod::rosmod_Callback_Options Sync_Callback_Options;
  Comp_sync_sub_options = ros${mod}::SubscribeOptions::Create<Std_Msgs::Bool>
    ("Component_Synchronization",
     1000,
     Boost::Bind(&$component_Name::Component_Synchronization_OnOneData, this, _1),
     ros${mod}::VoidPtr(),
     &this->compQueue,
     sync_callback_options);
#else
  comp_sync_sub_options = ros${mod}::SubscribeOptions::create<std_msgs::Bool>
    ("component_synchronization",
     1000,
     boost::bind(&$component_name::component_synchronization_OnOneData, this, _1),
     ros${mod}::VoidPtr(),
     &this->compQueue);
#end if
  this->comp_sync_sub = nh.subscribe(comp_sync_sub_options);

  ros${mod}::Time now = ros${mod}::Time::now();
  while ( this->comp_sync_sub.getNumPublishers() < this->num_comps_to_sync &&
	  (ros${mod}::Time::now() - now) < ros${mod}::Duration(comp_sync_timeout) )
    ros::Duration(0.1).sleep();
  ros::Duration(0.5).sleep();
  this->comp_sync_sub.shutdown();
  this->comp_sync_pub.shutdown();

  this->initOneShotTimer.start();
#if $len($timers)
#for $timer in $timers
  this->$(timer.properties["name"]).start();
#end for
#end if
  
#if $mod != ""
  compQueue.ROSMOD_LOGGER.CREATE_FILE(pwd + "ROSMOD_DEBUG." + nodeName + "." + compName + ".log");
#end if
}

extern "C" {
  Component *maker(ComponentConfig &config, int argc, char **argv) {
    return new ${component_name}(config,argc,argv);
  }
}
