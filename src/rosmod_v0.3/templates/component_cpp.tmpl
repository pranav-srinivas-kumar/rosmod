#unicode utf8
$hash_include "$package_name/${component_name}.hpp"

#if $component_type == "KSP"
KRPCI krpci_client;
#end if

#if $user_globals == ""
//# Start User Globals Marker
//# End User Globals Marker
#else
//# Start User Globals Marker
$user_globals//# End User Globals Marker
#end if

// Initialization Function
#if $init_business_logic == ""
//# Start Init Marker
void $component_name::Init(const ros${mod}::TimerEvent& event)
{
#if $mod != ""
  compQueue.ROSMOD_LOGGER.DEBUG("Entering $component_name::Init");
#end if
  // Initialize Here

  // Stop Init Timer
  initOneShotTimer.stop();
#if $mod != ""
  compQueue.ROSMOD_LOGGER.DEBUG("Exiting $component_name::Init");
#end if  
}
//# End Init Marker
#else
//# Start Init Marker
$init_business_logic//# End Init Marker
#end if

#if $len($subscribers) > 0
#for $sub in $subscribers
// Subscriber Callback - ${sub.properties["name"]}
#if $sub.properties["business_logic"] == ""
//# Start ${sub.properties["name"]}_OnOneData Marker
void $component_name::${sub.properties["name"]}_OnOneData(const $sub.properties["message_reference"].parent.properties["name"]::${sub.properties["message_reference"].properties["name"]}::ConstPtr& received_data)
{
#if $mod != ""
  compQueue.ROSMOD_LOGGER.DEBUG("Entering $component_name::${sub.properties["name"]}_OnOneData");
#end if
  // Business Logic for $sub.properties["name"] Subscriber

#if $mod != ""
  compQueue.ROSMOD_LOGGER.DEBUG("Exiting $component_name::${sub.properties["name"]}_OnOneData");
#end if
}
//# End ${sub.properties["name"]}_OnOneData Marker
#else
//# Start ${sub.properties["name"]}_OnOneData Marker
$sub.properties["business_logic"]//# End ${sub.properties["name"]}_OnOneData Marker
#end if
#end for

#end if
#if $len($provided_services) > 0
#for $server in $servers
// Server Callback - $server.properties["name"]
#if $server.properties["business_logic"] == ""
//# Start ${server.properties["service_reference"].properties["name"]}Callback Marker
bool $component_name::${server.properties["service_reference"].properties["name"]}Callback($server.properties["service_reference"].parent.properties["name"]::$server.properties["service_reference"].properties["name"]::Request  &req,
  $server.properties["service_reference"].parent.properties["name"]::$server.properties["service_reference"].properties["name"]::Response &res)
{
#if $mod != ""
  compQueue.ROSMOD_LOGGER.DEBUG("Entering $component_name::${server.properties["service_reference"].properties["name"]}Callback");
#end if
  // Business Logic for $server.properties["name"] Server

#if $mod != ""
  compQueue.ROSMOD_LOGGER.DEBUG("Exiting $component_name::${server.properties["service_reference"].properties["name"]}Callback");
#end if
  return true;
}
//# End ${server.properties["service_reference"].properties["name"]}Callback Marker
#else
//# Start ${server.properties["service_reference"].properties["name"]}Callback Marker
$server.properties["business_logic"]//# End ${server.properties["service_reference"].properties["name"]}Callback Marker
#end if
#end for

#end if
#if $len($timers) > 0
#for $timer in $timers
// Timer Callback - $timer.properties["name"]
#if $timer.properties["business_logic"] == ""
//# Start ${timer.properties["name"]}Callback Marker
void $component_name::${timer.properties["name"]}Callback(const ros::TimerEvent& event)
{
#if $mod != ""
  compQueue.ROSMOD_LOGGER.DEBUG("Entering $component_name::${timer.properties["name"]}Callback");
#end if
  // Business Logic for $timer.properties["name"] Timer

#if $mod != ""
  compQueue.ROSMOD_LOGGER.DEBUG("Exiting $component_name::${timer.properties["name"]}Callback");
#end if
}
//# End ${timer.properties["name"]}Callback Marker
#else
//# Start ${timer.properties["name"]}Callback Marker
$timer.properties["business_logic"]//# End ${timer.properties["name"]}Callback Marker
#end if
#end for

#end if

// Destructor - Cleanup Ports & Timers
$component_name::~${component_name}()
{
#if $len($timers) > 0
#for $timer in $timers
  ${timer.properties["name"]}.stop();
#end for
#end if
#if $len($publishers) > 0
#for $pub in $publishers
  ${pub.properties["name"]}.shutdown();
#end for
#end if
#if $len($subscribers) > 0
#for $sub in $subscribers
  ${sub.properties["name"]}.shutdown();
#end for
#end if
#if $len($provided_services) > 0
#for $server in $servers
  ${server.properties["name"]}.shutdown();
#end for
#end if
#if $len($required_services) > 0
#for $client in $clients
  ${client.properties["name"]}.shutdown();
#end for
#end if
#if $destructor == ""
  //# Start Destructor Marker
  //# End Destructor Marker
#else
  //# Start Destructor Marker
  $destructor  //# End Destructor Marker
#end if
}

// Startup - Setup Component Ports & Timers
void $component_name::startUp()
{
  ros${mod}::NodeHandle nh;
  std::string advertiseName;

  // Scheduling Scheme is FIFO
#if $mod != ""  
  this->compQueue.scheduling_scheme = rosmod::CallbackQueue::SchedulingScheme::FIFO;
  rosmod::ROSMOD_Callback_Options callback_options;
#end if  

#if $len($subscribers) > 0 
#for $sub in $subscribers
#if $mod != ""  
  callback_options.alias = "${sub.properties["name"]}_OnOneData";
  callback_options.priority = $sub.properties["priority"];
  callback_options.deadline.sec = ${int(sub.properties["deadline"].split('.')[0])};
  callback_options.deadline.nsec = ${int(float('0.' + (sub.properties["deadline"].split('.')[1]))*1000000000)};
#end if  
  // Component Subscriber - $sub.properties["name"]
  advertiseName = "${sub.properties["message_reference"].properties["name"]}";
  if (portGroupMap.find("$sub.properties["name"]") != portGroupMap.end())
    advertiseName += "_" + portGroupMap["${sub.properties['name']}"];
  ros${mod}::SubscribeOptions ${sub.properties["name"]}_options;
#if $mod != ""  
  ${sub.properties["name"]}_options = ros${mod}::SubscribeOptions::create<$sub.properties["message_reference"].parent.properties["name"]::${sub.properties["message_reference"].properties["name"]}>
      (advertiseName.c_str(),
       1000,
       boost::bind(&$component_name::${sub.properties["name"]}_OnOneData, this, _1),
       ros${mod}::VoidPtr(),
       &this->compQueue,
       callback_options);
  this->${sub.properties["name"]} = nh.subscribe(${sub.properties["name"]}_options);
#else
  ${sub.properties["name"]}_options = ros${mod}::SubscribeOptions::create<$sub.properties["message_reference"].parent.properties["name"]::${sub.properties["message_reference"].properties["name"]}>
      (advertiseName.c_str(),
       1000,
       boost::bind(&$component_name::${sub.properties["name"]}_OnOneData, this, _1),
       ros${mod}::VoidPtr(),
       &this->compQueue);
  this->${sub.properties["name"]} = nh.subscribe(${sub.properties["name"]}_options);  
#end if
#end for

#end if		
#if $len($publishers) > 0
#for $pub in $publishers
  // Component Publisher - $pub.properties["name"]
  advertiseName = "${pub.properties["message_reference"].properties["name"]}";
  if (portGroupMap.find("$pub.properties["name"]") != portGroupMap.end())
    advertiseName += "_" + portGroupMap["$pub.properties["name"]"];
  this->${pub.properties["name"]} = nh.advertise<$pub.properties["message_reference"].parent.properties["name"]::${pub.properties["message_reference"].properties["name"]}>(advertiseName.c_str(), 1000);
#end for

#end if
#if $len($provided_services)
#for $server in $servers
#if $mod != ""  
  callback_options.alias = "${server.properties["service_reference"].properties["name"]}Callback";
  callback_options.priority = $server.properties["priority"];
  callback_options.deadline.sec =${int(server.properties["deadline"].split('.')[0])};
  callback_options.deadline.nsec = ${int(float('0.' + (server.properties["deadline"].split('.')[1]))*1000000000)};
#end if    
  // Component Server - $server.properties["name"]
  advertiseName = "$server.properties["service_reference"].properties["name"]";
  if (portGroupMap.find("$server.properties["name"]") != portGroupMap.end())
    advertiseName += "_" + portGroupMap["$server.properties["name"]"];
  ros${mod}::AdvertiseServiceOptions ${server.properties["name"]}_server_options;
#if $mod != ""  
  ${server.properties["name"]}_server_options = ros${mod}::AdvertiseServiceOptions::create<$server.properties["service_reference"].parent.properties["name"]::$server.properties["service_reference"].properties["name"]>
      (advertiseName.c_str(),
       boost::bind(&$component_name::${server.properties["service_reference"].properties["name"]}Callback, this, _1, _2),
       ros${mod}::VoidPtr(),
       &this->compQueue,
       callback_options);
  this->${server.properties["name"]} = nh.advertiseService(${server.properties["name"]}_server_options);
#else
  ${server.properties["name"]}_server_options = ros${mod}::AdvertiseServiceOptions::create<$server.properties["service_reference"].parent.properties["name"]::$server.properties["service_reference"].properties["name"]>
      (advertiseName.c_str(),
       boost::bind(&$component_name::${server.properties["service_reference"].properties["name"]}Callback, this, _1, _2),
       ros${mod}::VoidPtr(),
       &this->compQueue);
  this->${server.properties["name"]} = nh.advertiseService(${server.properties["name"]}_server_options);  
#end if  
#end for
 
#end if
#if $len($required_services) > 0
  // Configure all required services associated with this component
#for $client in $clients
  // Component Client - $client.properties["name"]
  advertiseName = "$client.properties["service_reference"].properties["name"]";
  if (portGroupMap.find("$client.properties["name"]") != portGroupMap.end())
    advertiseName += "_" + portGroupMap["$client.properties["name"]"];
      this->${client.properties["name"]} = nh.serviceClient<$client.properties["service_reference"].parent.properties["name"]::$client.properties["service_reference"].properties["name"]>(advertiseName.c_str()); 
#end for

#end if
  // Init Timer
#if $mod != ""      
  callback_options.alias = "Init_Timer";
  callback_options.priority = 99;
  callback_options.deadline.sec = 1;
  callback_options.deadline.nsec = 0;
  ros${mod}::TimerOptions timer_options;
  timer_options = 
    ros${mod}::TimerOptions
    (ros::Duration(-1),
     boost::bind(&$component_name::Init, this, _1),
     &this->compQueue,
     callback_options
     true,
     true);
  this->initOneShotTimer = nh.createTimer(timer_options);    
#else  
  ros${mod}::TimerOptions timer_options;
  timer_options = 
    ros${mod}::TimerOptions
    (ros::Duration(-1),
     boost::bind(&$component_name::Init, this, _1),
     &this->compQueue,
     true);
  this->initOneShotTimer = nh.createTimer(timer_options);  
#end if  
#if $len($timers)
#for $timer in $timers
#if $mod != ""      
  callback_options.alias = "${timer.properties["name"]}Callback";
  callback_options.priority = $timer.properties["priority"];
  callback_options.deadline.sec = ${int(timer.properties["deadline"].split('.')[0])};
  callback_options.deadline.nsec = ${int(float('0.' + (timer.properties["deadline"].split('.')[1]))*1000000000)};
  // Component Timer - $timer.properties["name"]
  timer_options = 
    ros${mod}::TimerOptions
#if $timer.properties["period"] == "0.0"
    (ros::Duration(-1),
#else
    (ros::Duration($timer.properties["period"]),
#end if
     boost::bind(&$component_name::${timer.properties["name"]}Callback, this, _1),
#if $timer.properties["period"] == "0.0"
     &this->compQueue,
     callback_options,
     true,
     true);
#else
     &this->compQueue,
     callback_options,
     false,
     true);
#end if 
  this->$(timer.properties["name"]) = nh.createTimer(timer_options);  
#else 
  // Component Timer - $timer.properties["name"]
  timer_options = 
    ros${mod}::TimerOptions
#if $timer.properties["period"] == "0.0"
    (ros::Duration(-1),
#else
    (ros::Duration($timer.properties["period"]),
#end if
     boost::bind(&$component_name::${timer.properties["name"]}Callback, this, _1),
#if $timer.properties["period"] == "0.0"
     &this->compQueue, true);
#else
     &this->compQueue);
#end if 
  this->$(timer.properties["name"]) = nh.createTimer(timer_options);
#end if
#end for

#end if
  // Identify the pwd of Node Executable
  std::string s = node_argv[0];
  std::string exec_path = s;
  std::string delimiter = "/";
  std::string exec, pwd;
  size_t pos = 0;
  while ((pos = s.find(delimiter)) != std::string::npos) {
    exec = s.substr(0, pos);
    s.erase(0, pos + delimiter.length());
  }
  exec = s.substr(0, pos);
  pwd = exec_path.erase(exec_path.find(exec), exec.length());
  std::string log_file_path = pwd + nodeName + "." + compName + ".log"; 
  
  // Create the log file & open file stream
  LOGGER.CREATE_FILE(log_file_path);
  
  // Establish log levels of LOGGER
  LOGGER.SET_LOG_LEVELS(logLevels);

#if $component_type == "KSP"
  krpci_client.SetName(nodeName + "_" + compName);
#end if
#if $mod != ""
  compQueue.ROSMOD_LOGGER.CREATE_FILE(pwd + "ROSMOD_DEBUG." + nodeName + "." + compName + ".log");
#end if
}

extern "C" {
  Component *maker(ComponentConfig &config, int argc, char **argv) {
    return new ${component_name}(config,argc,argv);
  }
}
